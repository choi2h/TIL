# 4장. 유스케이스 구현하기


육각형 아키텍처는 도메인 중심의 아키텍처에 적합하기 때문에 도메인 엔티티를 만드는 것으로 시작한 후 해당 도메인 엔티티를 중심으로 유스케이스를 구현하겠다.

<br/>

## 유스케이스의 순서
1. 입력을 받는다. (인커밍 어댑터로부터 입력을 받음)
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다. 또한, 다른 아웃고잉 어댑터를 호출할 수 있다.

입력을 받는 단계를 **입력 유효성 검증** 이라고 부르지 않는 이유
- **유스케이스 코드가 도메인 로직에만 신경 써야하고 입력 유효성 검증으로 오염되면 안된다.**
- **그러나 유스케이스는 비즈니스 규칙을 검증할 책임이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.**

넓은 서비스 문제를 피하기 위해 모든 유스케이스를 한 서비스 클래스에 모두 넣지 않고 각 유스케이스별로 분리된 각각의 서비스로 만들어보자.

<br/>
<br/>                

## 입력 유효성 검증과 비즈니스 규칙

- 입력 유효성 검증
    - 유스케이스 로직의 일부가 아니다.
    - 선언적으로 구현할 수 있다.
    - 구문상의 유효성 검증
- 비즈니스 규칙 검증
    - 유스케이스 로직의 일부로 포함된다.
    - 현재 상태에 접근해야한다.
    - 유스케이스의 맥락 속에서 의미적인 유효성 검증
                     
<br/>

### 입력 유효성 검증

유스케이스가 입력 유효성 검증을 할 경우
- 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 된다.
- 모델의 상태를 해칠 수 있다.

그렇다면 유스케이스 클래스가 아닌 어디에서 입력 유효성 검증을 해야할까?  
`입력 모델`의 생성자에서 문제를 다루며 이를 통해 유스케이스 구현체 주위에 사실상 `오류 방지 계층`을 만들 수 있다.  
-  여기서 말하는 계층은 잘못된 입력을 호출자에게 돌려주는 유스케이스 보호막을 의미한다.
-  Java의 `Bean ValidatoinAPI` 라이브러리를 사용해 API를 이용하면 유효성 규칙들을 필드의 에너테이션으로 표현 가능하다.
- `생성자를 직접 사용하자.`
    - 새로운 필드를 추가하거나 필드를 삭제할 때마다 컴파일 에러를 따라 나머지 코드에 변경사항을 반영할 수 있다.
- `유스케이스마다 다른 입력 모델을 사용해야 한다.`
    - 유스케이스를 훨씬 명확하게 만들 수 있다.
    - 다른 유스케이스와의 결합도를 제거해서 불필요한 부수효과가 발생하지 않게 한다.

  
<br/>
  

### 비즈니스 규칙 검증

- **가장 좋은 방법**  `비즈니스 규칙을 도메인 엔티티 안에 넣자.`
    - 이 규칙을 지켜야하는 비즈니스 로직 바로 옆에 규칙이 위치하기 때문에 위치를 정하는 것도 쉽고 추론하기도 쉽다.
- 위 방법이 여의치 않다면 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.
    - 유효성을 검증하는 코드를 호출하고, 유효성 검증이 실패할 경우 유효성 검증 전용 예외를 던진다.
    - 사용자와 통신하는 어댑터는 이 예외를 에러 메시지로 사용자에게 보여주거나 적절한 다른 방법으로 처리한다.

EX. 도메인 엔티티 안에 넣는 방법 예시  
비즈니스 규칙 : 출금 계좌는 초과 인출되어서는 안된다.

```java
public class Account {
    
    public boolean withdraw(Money money, AccountId, targetAccountId) {
        if(!mayWithdraw(money)) {
            return false;
        }
        //...
    }
}
```
  
<br/>
<br/>
  

## 풍부한 도메인 모델 vs 빈약한 도메인 모델
  
### 풍부한 도메인 모델
- 애플리케이션의 코어에 있는 엔티티에서 가능한 한 많은 도메인 로직 구현
    - 엔티티들은 상태를 변경하는 메서드를 제공
    - 비즈니스 규칙에 맞는 유효한 변경만을 허용
- 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치한다.
    - 유스케이스는 도메인 모델의 진입점으로 동작

### 빈약한 도메인 모델
- 엔티티 자체가 굉장히 얇다. 
    - getter, setter 메서드만 포함한다.
    - 어떤 도메인 로직도 갖고 있지 않다.
- 도메인 로직은 유스케이스 클래스에 구현된다.
    - 비즈니스 규칙을 검증
    - 엔티티 상태 변경
    - 데이터베이스 저장을 담당하는 아웃고잉 포트에서 엔티티를 전달할 책임

  

<br/>
<br/>

## 유스케이스마다 다른 출력 모델

`유스케이스는 가장 구체적인 최소한의 값을 반환해야 한다.`
- 유스케이스 간에 같은 출력 모델 공유 시 문제점
    - 유스케이스들이 강하게 결합된다. 
- 해결 방법  
    - 단일 책임 원칙을 적용하고 모델을 분리해서 유지하자.
- 유스케이스별로 모델을 만들 시 장점
    - 유스케이스를 명확하게 이해할 수 있다.
    - 장기적으로 유지보수하기 더 쉽다. 
    - 여러 개의 유스케이스를 동시에 작업할 수 있다.