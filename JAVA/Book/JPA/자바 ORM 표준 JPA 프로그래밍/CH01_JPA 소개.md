# CH01. JPA 소개

### JPA를 알게 된 후 얻은 보상

- 데이터 저장 계층에 작성해야할 코드가 3/1로 줄어들었다.  
    - CRUD SQL을 일일이 작성할 필요가 없다.
    - 조회된 결과를 객체로 매핑하는 작업이 대부분 자동으로 처리된다.
- 애플리케이션을 SQL이 아닌 객체 중심으로 개발을 할 수 있다.    
    - 생산성과 유지보수가 확연히 좋아졌다.
    - 테스트를 작성하기도 편리해졌다.

<br/>
<br/>   

## 1.1 SQL을 직접 다룰 때 발생하는 문제점

데이터베이스는 객체구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수는 없다. 때문에 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 진행해주어야 한다.   

→ 문제 : **CRUD를 위해 너무 많은 SQL과 JDBC API를 코드로 작성하는데 시간을 투자해야한다** 는 것, 객체의 필드를 추가/수정/삭제 시 관련된 모든 SQL과  **JDBC API를** 수정해야 한다.

  

### 문제점
- 진정한 의미의 계층 분할이 어렵다.
- 엔티티를 신뢰할 수 없다.
    - 엔티티(Entity) : 비즈니스 요구사항을 모델링한 객체
- SQL에 의존적인 개발을 피하기 힘들다.

<br/>
<br/>

Member 클래스에 새롭게 team 필드를 추가해야된다고 하자.

```
public class Member {
    private Long memberId;
    private String name;
    private Address address;
    private Team team; //새로 추가
}

class Team {
    private String teamName;
}
```

다음 코드를 통해서 화면에 팀 이름을 출력하고자 한다.

```
member.getTeam.getTeamName(); 
```

그러나 데이터베이스에는 모든 멤버가 팀을 가지고 있음에도 불구하고 null이 반환되었다.  

이런 문제 발생 시  DAO를 열어서 어떤 SQL이 실행되고 어떤 객체들이 함께 조회되는지 일일이 확인하여 문제를 파악하고 해결해야 한다. 이처럼 SQL에 든 것을 의존하는 상황에서는 개발자들이 엔티티를 신뢰하고 사용할 수 없다. **이것은 진정한 의미의 계층 분할이 아니다.**

<br/>

### JPA와 문제 해결

JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다. 그러면 JPA가 개발자 대신에 적절한 SQL을 생성해서 데이터베이스에 전달한다.

→ 객체의 필드를 추가/수정/삭제하더라도 JPA에게 알려주기만하면 알아서 처리해준다.

<br/>

**JPA의 CRUD API**

```
//저장기능
jpa.persist(member);

//조회 기능
String memberId = "id";
Member member = jpa.find(Member.class, memberId);

//수정 기능
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경");

//연관 객체 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam(); 
```

  

setName();만 했는데 어떻게 데이터베이스에 값이 수정되었는지, member만 가져왔는데 어떻게 team까지 가져올 수 있었는지 앞으로 알아가보자.

  
<br/>
<br/> 

## 1.2 패러다임의 불일치

**객체와 관계형 데이터베이스의 패러다임 불일치 문제란?**   
객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법도 다른 것

관계형 데이터베이스 특징
- 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 
- 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다. 

따라서 **객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.** 

<br/>
  
### 상속 : 상속받은 데이터를 저장하고 싶을 때

JDBC API  
부모 객체에서 부모 데이터만 꺼내서 부모용 INSERT SQL을 작성하고 자식 객체에서 자식 데이터만 꺼내서 자식용 INSERT SQL을 작성해야 하는데, 작성해야 할 코드량이 만만치 않다. 조회도 마찬가지로 각각 여러번의 작업을 해야한다.

  

JPA  
상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다. `jpa.persist()` 를 통해 자식 객체를 저장한다면 부모 데이터와 자식 데이터를 알아서 찾아 저장 해준다. 조회도 마찬가지로 자식객체를 조회하면 부모와 자식 두 테이블을 조인해서 결과가 반환된다.

 <br/> 

### 연관관계

**참조 방법**

객체 : 참조를 사용하는 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회  
테이블: 외래키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회


**SQL을 직접 다룰 때 문제점**

```
public class Member {
    private Long memberId; //PK
    private String name;
    private Address address;
    private int teamId; //외래키를 통한 연관관계 설정
}

public class Team {
    private int teamId; //PK
    private String teamName;
}

```

우리는 이처럼 테이블 구조에 맞춰 외래키를 객체의 속성으로 사용하여 참조하게 된다.  
그러나 관계형 데이터베이스는 조인 이라는 기능이 있으므로 외래 키의 값을 그대로 보관해도 되지만, 객체는 연관된 객체의 참조를 보관해야 다음처럼 참조를 통해 연관된 객체를 찾을 수 있다.

`Team team = member.getTeam()`   

```
public class Member {
    private Long memberId; //PK
    private String name;
    private Address address;
    private Team team; //참조로 연관관계 설정
}

class Team {
    private int teamId; //PK
    private String teamName;
}
```

이처럼 객체지향적 모델링을 통해 객체를 참조하게 된다면 `Team team = member.getTeam()` 로 연관된 참조를 조회할 수 있다. 그러나 객체지향 모델링을 사용한다면 결국 개발자가 중간에서 변환 역할을 하게 된다.

<br/>

**연관관계와 관련된 패러다임의 불일치 문제를 해결해주는 JPA**   
객체와 참조객체의 연관 관계를 설정하고 객체를 저장하면 JPA는 참조객체를 외래키로 변환해서 SQL을 데이터베이스에 전달한다. 조회도 마찬가지로 연관객체를 필요 시 외래키로 조회해서 참조객체를 반환 해준다.

  
<br/>
  

### 객체 그래프 탐색

객체의 참조를 사용해서 연관된 참조 객체를 찾는 것을 객체 그래프 탐색이라고 한다.

위에서 설명했듯이 JPA는 연관된 **객체를 사용하는 시점** 에 적절한 SELECT SQL을 실행해주듯 객체 탐색을 자동으로 처리 해준다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 **지연로딩** 이라 한다. 이 내용은 뒤에서 알아보자.

<br/>
<br/>

### 비교

- 데이터베이스 : 기본 키의 값으로 로우 구분
- 객체 : 동일성 비교와 동등성 비교라는 두가지 비교 방법이 있음
    - 동일성 비교 : ==비교로 객체 인스턴스의 주소 값을 비교한다.
    - 동등성 비교 : equals()메서드를 사용해서 객체 내부의 값을 비교한다.

```
//SQL 실행
String memberId = 100;
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);

member1 == member2; // false
member1.equals(member2); // True

//JPA 실행
Member member3 = jpa.find(Member.class, memberId);
Member member4 = jpa.find(Member.class, memberId);

member3 == member4; // True
member3.equals(member4); // True
```

SQL  
같은 데이터베이스 로우에서 조회했지만, 객체 측면에서 볼 때 둘은 다른 인스턴스기 때문에 동일성 비교에서 같지 않다는 결과가 나온다. 

JPA   
같은 트랜잭션일 때 같은 객체가 조회되는 것이 보장되어 동일성 비교에 같다는 결과가 나오게 된다. 

<br/>
<br/>

## 1.3 JPA란 무엇인가?
JPA는 애플리케이션과 JDBC 사이에서 동작하는 자바 진영의 ORM 기술 표준이다.

  

ORM이란?
Object-Relational Mapping의 약자로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다. 

ORM프레임워크의 역할
- SQL을 개발자 대신 생성해서 데이터베이스에 전달
- 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 해결 해줌

이에 따른 이점
- **객체 측면에서는 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링 할 수 있게 된다.**  (둘을 어떻게 매핑해야 하는지 매핑 방법만 ORM프레임워크에게 알려주면 된다.)
- **데이터 중심인 관계형 데이터베이스를 사용해서 객체지향 애플리케이션 개발에 집중할 수 있다.** 

<br/>  

### JPA 소개  
JPA는 ORM 기술에 대한 API표준 명세로 인터페이스를 모아둔 것이라고 할 수 있다.
JPA라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있는 장점이 있다. 

**JPA 버전별 특징**    

- JPA 1.0 2006년 : 초기 버전으로 복합키와 연관관계 기능이 부족했다.
- JPA 2.0 2009년 : 대부분의 ORM 기능을 포함하고 JPA Criteria가 추가되었다.
- JPA 2.1 2013년 : 스토어드 프로시저 접근, 컨버터, 엔티티 그래프 기능이 추가되었다.

<br/> 

### 왜 JPA를 사용해야 하는가?

- 생산성  
    데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.  
    - JPA를 사용시, 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달만 하면된다.
    - 반복적인 CRUD SQL을 직접 작성하지 않아도 된다.
    - DDL문을 자동적으로 생성해주는 기능도 있다. 

- 유지보수
    - 개발자가 직접 유지보수해야 하는 코드 수가 줄어들게 된다.  
    객체의 필드를 추가/수정/삭제 시 관련된 모든 SQL과 JDBC API코드를 모두 변경해야 했으나, JPA를 사용하면 이런 과정을 JPA가 알아서 대신 처리해준다.
    - JPA는 패러다임의 불일치 문제를 해결해준다.  
    객체지향 언어가 가진 장점들을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있다.  

- 패러다임의 불일치 해결  
    위에서 말했듯이 JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임 불일치 문제를 해결해준다.

- 성능  
    애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다.

- 데이터 접근 추상화와 벤더 독립성

    - 문제점  
    관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많다.   
    이로인해 애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기는 매우 어려워진다.   
    ex) 페이징 처리는 데이터베이스마다 달라서 사용법을 각각 배워야 한다.
    - 해결  
    JPA는 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.  
    ex) 로컬에서는 H2데이터베이스를 사용하고 개발이나 상용환경은 오라클이나 MySQL을 사용한다.

- 표준  
    JPA는 자바 진영의 ORM기술 표준이다. 표준을 사용하면 다른 구현 기술로 손쉽게 변경이 가능하다.


<br/>
<br/>  

## Q&A | ORM에 대한 궁금증과 오해

### Q. 성능이 느리진 않나요?
- 다양한 성능 최적화 기능을 제공해서 잘 이해하고 사용하면 SQL보다 더 좋은 성능을 낼 수 있다.  
    
- 잘 이해하지 못하고 사용하면 N+1과 같은 문제로 인해 심각한 성능 저하가 발생할 수 있다.  
    - N+1문제란 : 한 번 SQL을 실행해서 조회한 수만큼 N번 SQL을 추가로 실행하는 문제

<br/>  

### Q. 통계 쿼리처럼 매우 복잡한 SQL은 어떻게 하나요?

- JPA는 통계 쿼리 같이 복잡한 쿼리보다는 실시간 처리용 쿼리에 더 최적화 되어있다.
- 상황에 따라 JPA가 제공하는 네이티브 SQL을 사용하거나 마이바티스나 스프링의 Jdbc Template같은 SQL매퍼 형태의 프레임워크를 혼용하는 것도 좋은 방법이다.

 <br/> 

### Q. 마이바티스와 어떤 차이가 있나요?

- 마이바티스, 스프링의 Jdbc Template →  보통 SQL 매퍼라고 한다.
    
- SQL 매퍼
    - SQL과 매핑할 객체만 지정하면 JDBC API 사용과 응답 결과를 객체로 매핑하는 일은 SQL대신 처리해준다. → 개발자가 SQL을 직접 작성해야하므로 SQL에 의존하는 개발은 피할 수 없게 된다.

- ORM
    - 객체와 테이블을 매핑만 하면 ORM프레임워크가 SQL을 만들어서 데이터베이스와 관련된 처리를 해준다. → SQL에 의존하는 개발을 피할 수 있다.