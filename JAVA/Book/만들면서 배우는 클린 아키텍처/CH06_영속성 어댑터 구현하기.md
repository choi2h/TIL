## 6장 영속성 어댑터 구현하기


`서비스 (호출)-> 아웃고잉 포트[interface] <-(구현) 영속성 어댑터`

**육각형 아키텍처에서의 영속성 어댑터**

- ‘주도되는' 혹은 ‘아웃고잉'어댑터
- 애플리케이션에 의해 호출될 뿐, 애플리케이션을 호출하지는 않는다.

<br/>

아웃고잉 포트  

- 애플리케이션 서비스와 영속성 코드 사이의 간접적인 계층이다.
- 영속성 계층에 대한 코드 의존성을 없애기 위해 간접 계층을 추가한다.
- 영속성 코드를 리팩터링하더라도 코어 코드를 변경하는 결과로 이어지지 않을 것이다.
- 런타임에도 의존성은 애플리케이션 코어에서 영속성 어댑터로 향한다.

<br/>
<br/>

## 영속성 어댑터의 책임

1. 입력을 받는다. (포트 인터페이스를 통해 입력을 받음)
2. 입력을 데이터베이스 포맷으로 매핑한다.
3. 입력을 데이터베이스로 보낸다.
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.

- 출력 모델이 영속성 어댑터가 아닌 애플리케이션 코어에 위치한다.
- 영속성 어댑터의 입력 모델이 애플리케이션 코어에 위치한다.
    - 영속성 어댑터 내부를 변경하는 것이 코어에 영향을 미치지 않는다.


<br/>
<br/>

## 포트 인터페이스 나누기

- Account에 관련된 데이터베이스 연산을 하나의 리포지토리 인터페이스 AccountRepository에 넣어두는게 일반적이다.
    - 각 서비스는 단 하나의 메서드만 사용하더라도 하나의 넓은 포트 인터페이스에 의존성을 갖게 된다. 
    - 코드에 불필요한 의존성이 생겼다는 뜻이다.

> 필요없는 화물을 운반한는 무언가에 의존하고 있으면 예상하지 못했던 문제가 생길 수 있다.

- 인터페이스 분리 원칙은 이 문제의 답을 제시한다.  
    - 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 한다.   
    ex) LoadAccountPort / UpdateAccountStatePort / CreateAccountPort
- 매우 좁은 포트를 만드는 것은 코딩을 플러그 앤드 플레이 경험으로 만든다. 
    - 서비스 코드를 짤 때는 필요한 포트에 그저 꽂히기만 하면 된다.

<br/>
<br/>  

## 영속성 어댑터 나누기

- 도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지에 관심없다.
- 모든 포트가 구현돼 있기만 한다면 영속성 계층에서 하고 싶은 어떤 작업이든 해도 된다.
- ‘에그리거트당 하나의 영속성 어댑터' 접근 방식 또한 나중에 여러 개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기 위한 좋은 토대가 된다.
    - 바운디드 컨텍스트 : 경계
    - 어떤 맥락이 다른 맥락에 있는 무엇인가를 필요로 한다면 전용 인커밍 포트를 통해 접근해야 한다.
- 영속성 측면과의 타협 없이 풍부한 도메인 모델을 생성하고 싶다면 도메인 모데로가 영속성 모델을 매핑하는 것이 좋다.

<br/>
<br/>

## 데이터베이스 트랜잭션은 어떻게 해야할까?

- 트랜잭션 : 하나의 특정한 유스케이스에 대해서 일어나는 모든 쓰기 작업에 걸쳐 있어야 한다. 
    - 그래야 그중 하나라도 실패할 경우 다 같이 롤백 될 수 있다.
- 영속성 어댑터는 어떤 데이터베이스 연산이 같은 유스케이스에 포함되는지 알지 못한다.
    - 언제 트랜잭션을 열고 닫을지 결정할 수 없다.
    - 이 책임은 영속성 어댑터 호출을 관장하는 서비스에 위임해야 한다.
- 서비스 클래스에 @Transaction 애너테이션을 붙여서 스프링이 모든 public메서드를 트랜잭션으로 감싸게 하자.
- 위 방법이 싫다면 Aspectj같은 도구를 이용해 관점 지향 프로그래밍으로 트랜잭션 경계를 코드에 위빙할 수 있다.